좋은코드 = 이해하기 쉬운 코드
좋은 주석
	법적인 주석
	정보를 제공하는 주석  --> 자신의 생각을 기록하는 것
	의도를 설명하는 주석
	의미를 명료하게 밝히는 주석  --> 상수에 대한 설명
	결과를 경고하는 주석
	todo 주석
	중요성을 강조하는 주석
나쁜주석
	같은 이야기를 중복하는 주석	
	오해할 여지가 있는 주석
	의무적으로 다는 주석 --> 코드에서 유추할 수 있는 내용의 주석
	이력을 기록하는 주석
	있으나 마나 한 주석	
	위치를 표시하는 주석	
	닫는 괄호에 다는 주석
	주석으로 처리한 코드
	너무 많은 정보  --> 설명 자체를 위한 설명 
주석에 담아야 하는 대상
	코드를 읽는 사람이 콬드를 적성한 사람만큼 코드를 잘 이해할 수 있게 도울 수 있어야 한다.

읽기 쉬운 흐름제어 만들기
	조건문 
		왼쪽 값은 유동적인 값 오른쪽은 고정적인 값
			if(length >= 10)
		if/else 블록의 순서(긍정먼저)
형식 맞추기
	소스코드의 길이
		100줄 내외의 짧은 길이
	개념은 빈 행으로
		패키지, import, 각 함수
	세로 밀집도
		밀접한 코드행은 세로 가까이
	변수선언
		사용하는 위치에 최대한 가까이

예외 처리
	가독성을 높이는 예외처리
		요류코드 사용 x
		Null을 반환하거나 전달하지 말 것
	예외는 진짜 예외 상황에서만 사용
	복구 --> 검사예외 , 프로그래밍 오류 --> 런타임 예외
	필요없는 검사 예외는 사용 x
	예외 무시 x
		catch블록을 비워두는 경우
자료구조의 선택기준
	시간 복잡도 linkedlist < ArrayList(linkedlist가 더 빠르다)
	공간 복잡도 linkedlist > ArrayList(ArrayList가 공간이 더 적게 든다)
	동시성
자료구조의 종류
	비트 마스크 
		-이진수 표현을 자료구조로 쓰는 기법
			더 빠른 수행시간
			더 간결한 코드
			더 작은 메모리 사용량
		-비트 마스크의 연산
			&,|,^,~,<<,>>		
	선형 자료구조(동적배열, 연결 리스트)
		-동적 배열
			배열의 특징을 가짐
				메모리의 연속된 위치에 저장
				주어진 위치에 대한 원소 반환
			추가적인 특징
				배열의 크기 변경 가능
		-연결 리스트
			배열의 원소들의 순서를 유지하면서 임의의 위치에 원소 삽입, 삭제를 수행
		
	큐,스택,데크
		-연결 리스트를 통한 구현
			양쪽 끝에서의 삽입, 삭제가 상수 시간에 가능
			하지만, 노드의 할당,삭제,접근 등에 시간이 걸림
		-동적 배열을 통한 구현
			스택의 경우 쉽게 구현가능
			큐, 데크의 경우 삽입, 삭제 시 시간이 O(n) 시간 소요
			
컴파일러
	
	high level language(고급언어) 를 machine language(기계언어)로 해석한다.
인터프리터
	프로그램과 기계어의 중간 코드로 생성하여 그 중간 코드를 해석 실행하는 번역 프로그램
	목적 프로그램을 출력하지 않는 것이 컴파일러와 크게 구분된다. (BASIC,APL)
JLT 컴파일러
	인터프리트 방식과 컴파일 방식을 혼합한 방식
		실행 시점에서 인터프리트 방식으로 기계어 코드를 생성하면서 그 코드를 캐싱하여 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지 	
	JVM에서 지원
		자바 컴파일러가 프로그램 코드를 바이트 코드로 변환한 다음, 실제 바이트 코드를 실행하는 시점에서 바이트코드(인터프리터)를 JLT 컴파일을 통해 기계어(compile)로 변환
inlining 
	컴파일 최적화
메모리관리
	garbage collection : 오랫동안 사용되지 않는 object(garbage)가 차지하고 있는 메모리 공간을 재활용한다.
		메모리에 있는 object를 스캔하고 사용되지 않는 object를 식별한다
		이러한 object들이 차지하고 있는 공간을 재활용한다.
	Aprproaches to GC
		Reference Counting
			각 object는 reference 횟수를 센다
			만약 object 의 횟수가 0이면 이건은 garbage이다
			장점  
				상대적으로 구현이 쉽다
				개념이 쉽다
			단점
				모든 garbage obejct가 free 된다고 보장할 수 없다
				overhead가 발생한다.
			       
		Mark and Sweep
			roots에서 부터 object를 스캔하면서 mark한다
			mark되지 않은 object를 heap에서 제거한다.
			장점
				reference counting 의 단점을 극복한다.
				구현과 개념이 쉽다
				모든 garbage object가 free된다고 보장한다.
			단점
				cpu를 많이 사용해야한다
				GC가 실행되는 동안 모든 thread가 멈춰야한다.
		Copy Collection
			heap을 start 공간과 end 공간으로 나눈다
			object는 start 공간에 할당된다
			GC가 수행되는 동안 marking 대신에 사용하는 object를 복사해 end space로 옮긴다.
			장점
				mark and sweep의 단점을 보안했다
				garbage를 free하기 위해서 스캔 할 필요가 없다
				fragmentation이 없다
			단점
				느리다
				병행될 수 없다.(mar and sweep 단점)
		Generational Colletion
			object 생명주기는 garbage가 될 가능성가 반비례하는 경향이 있다
			young ojbect는 빠르게 죽고 old object는 계속 살아있다.